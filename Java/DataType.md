# DataType 자료형 

## 원시(기본)형 Primitive type

| 분류   | 타입    | 할당되는 메모리 크기 | 기본값        | 데이터의 표현 범위                                     |
| ------ | ------- | -------------------- | ------------- | ------------------------------------------------------ |
| 논리형 | boolean | 1 byte               | false         | true, false                                            |
| 정수형 | byte    | 1 byte               | 0             | -128 ~ 127                                             |
|        | short   | 2 byte               | 0             | -32,768 ~ 32,767                                       |
|        | int     | 4 byte               | 0             | -2,147,483,648 ~ 2,147,483,647                         |
|        | long    | 8 byte               | 0L            | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| 실수형 | float   | 4 byte               | 0.0F          | (3.4 X 10-38) ~ (3.4 X 1038) 의 근사값                 |
|        | double  | 8 byte               | 0.0 또는 0.0D | (1.7 X 10-308) ~ (1.7 X 10308) 의 근사값               |
| 문자형 | char    | 2 byte (유니코드)    | '\u0000'      |                                                        |

- 기본값이 있기 때문에 null이 존재하지 않습니다. 
    - 만약 null을 넣고 싶다면 참조형를 활용합니다.
- 실제 값을 저장하는 공간으로 스택 메모리에 저장됩니다.
- 컴파일 시점에 담을 수 없는 값을 할당하면 컴파일 에러가 발생합니다.

### 단정도와 배정도란

컴퓨터는 소수점을 딱 떨어지는 정확한 값이 아니라 정확한 값에 가까운 근사치를 저장하고 계산합니다.
이를 계산하는 부동소수점을 표현하는 방식은 가장 널리 쓰이는 표준인 IEEE 754 에 따라 32 비트 단정도 (single-precision), 64 비트 배정도 (double-precision) 로 분류 되는데 float 은 단정도에, double은 배정도와 대응됩니다.

### 정수형 타입의 유의사항

할당된 데이터가 타입의 최대/최소 표현 범위를 벗어나면 오버플로우/언더플로우가 발생하여 의도하지 않는 값이 저장 됩니다.

- 오버플로우 (overflow) : 해당 타입이 표현할 수 있는 '최대 표현 범위' 보다 큰 수를 저장할 때 발생.
- 언더플로우 (underflow) : 해당 타입이 표현할 수 있는 '최소 표현 범위' 보다 작은 수를 저장할 때 발생.

### 실수형 타입의 유의사항

- 실수형 타입을 결정할 때에는 표현 범위 뿐만 아니라, 유효 자릿수를 고려해야 합니다. 
- 정확한 계산이 필요할 경우에는 BigDecimal, int, long 타입을 사용합니다.
  - int (9 자리 이하) , long (18 자리 이하), BigDecimal (18자리 초과)
  - BigDecimal를 은 정확한 연산을 제공하지만, 기본형 타입보다 사용하기 불편하고 실행 속도가 느려집니다.

## 참조형  Reference type

|    분류    |    타입     | 기본값 |  할당되는 메모리 크기  |
| :--------: | :---------: | :----: | :--------------------: |
|    배열    |    Array    |  Null  | 4 byte (객체의 주소값) |
|    열거    | Enumeration |  Null  | 4 byte (객체의 주소값) |
|   클래스   |    Class    |  Null  | 4 byte (객체의 주소값) |
| 인터페이스 |  Interface  |  Null  | 4 byte (객체의 주소값) |

- 빈 객체를 의미하는 Null이 존재합니다.
- 값의 주소값을 저장하는 공간으로 힙 메모리에 저장됩니다,
- 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 런타임 에러가 발생합니다.(NullPointException 등)

## 래퍼 클래스 Wrapper Class

| Primitive Type | Wrapper Class |
| -------------- | -------------- |
| boolean        | Boolean        |
| char           | Character      |
| byte           | Byte           |
| short          | Short          |
| int            | Integer        |
| long           | Long           |
| float          | Float          |
| double         | Double         |


- 기본 타입의 데이터를 객체로 취급해야할 때 사용합니다.
    - 메소드의 인수로 객체 타입만이 요구되는 경우.


## 그외

### BigInteger / BigDecimal

BigInteger 클래스는 무한한 크기의 정수형 숫자를 다룰 수 있습니다.   
BigDecimal 클래스는 무한한 크기의 부동 소수점 숫자를 다룰 수 있습니다. 

### 타입 변환 Type conversion

boolean형을 제외한 나머지 기본형 타입끼리는 타입 변환을 자유롭게 할 수 있습니다. 

> 묵시적 타입 변환 (자동) Implicit Conversion, Promotion

데이터의 손실이 발생하지 않도록 작은 범위의 타입에서 넓은 범위의 타입으로 변환할 때 컴파일러가 자동으로 변환합니다.  
(byte → short, char → int → long → float → double)

> 명시적 타입 변환 (강제) Explicit Conversion, Casting

묵시적 타입 변환이 불가능한 경우, 사용자가 강제적으로 변환합니다. 즉, 넓은 범위의 타입에서 작은 범위의 타입으로 변환시키는 것이고, 이 때 데이터 손실이 일어납니다.


### 변수 (Variable) vs 상수 (Constant) vs 리터럴 (Literal) 
> 변수
- 데이터를 저장할 메모리 공간을 의미합니다.
- 선언과 동시 초기화, 선언 후 초기화 모두 가능 합니다.

> 상수
- 상수는 선언과 동시에 초기화되며, 이후 변환되지 않는 변수를 의미합니다.

> 리터럴
- 값 그 자체로 변수와 상수와는 달리 저장된 메모리 공간을 가리키는 이름이 없습니다.

```
char a = 'c'    // (변수) = (리터럴)
final int b = 4 // (상수) = (리터럴)
```