API Versioning 은 불특정 다수의 컨슈머가 접속하는 OpenAPI 를 지원하기 위한 필수적인 요소 중 하나입니다.  
설령 컨슈머가 한 곳이라고 하더라도 원활한 적용과 장애 시간 최소화를 위해 고려할 수 있습니다. (물론 훌륭한 배포 전략을 준비하면 더 좋습니다.)  
아래는 `일상 속 사물이 알려주는 웹 API 디자인 - 아노드 로렛 저` 를 읽고 해결한 개인적인 고민과 경험입니다.

```text
브레이킹 체인지: 호환성을 (특히 하위 호환성) 지원하지 않게 되는 변경
컨슈머: API 를 사용하는 클라이언트 (프론트)
프로바이더: API 를 제공하는 서버 (백엔드)
```

## Versioning (브레이킹 체인지 회피) 전략

API 를 제공하다보면 브레이킹 체인지를 만나는건 필연입니다.
다만 어떤 전략으로 운영함에 따라 컨슈머가 변화를 더 빠르고 잘 인지하고, 프로바이더는 더 적은 변화의 개발을 할 수 있습니다.

| 전략         | v1                                                                                      | v2                                                                                      |
|------------|-----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| 경로         | GET /v1/transfers<br>Host: api.bankingcompany.com                                       | GET /v2/transfers <br>Host: api.bankingcompany.com                                      |
| 도메인        | GET /transfers <br>Host: api.bankingcompany.com                                         | GET /transfers <br>Host: apiv2.bankingcompany.com                                       |
| 쿼리 파라미터    | GET /transfers?version=1 <br>Host: api.bankingcompany.com                               | GET /transfers?version=2 <br>Host: api.bankingcompany.com                               |
| 커스텀 헤드     | GET /transfers <br>Host: api.bankingcompany.com <br>Version: 1                          | GET /transfers <br>Host: api.bankingcompany.com <br>Version: 2                          |
| 콘텐츠 네고시에이션 | GET /transfers <br>Host: api.bankingcompany.com <br>Accept: application/vnd.bank.1+json | GET /transfers <br>Host: api.bankingcompany.com <br>Accept: application/vnd.bank.2+json |
| 컨슈머의 설정    | GET /transfers <br>Host: api.bankingcompany.com <br>Authorization: Bearer 4R57TD78      | GET /transfers <br>Host: api.bankingcompany.com <br>Authorization: Bearer 4R57TD78      |

도메인 전략과 쿼리 파라미터 전략은 가장 선호하지 않는 전략입니다.

- 도메인 버저닝 전략은 작은 변경에도 도메인이라는 비교적 큰 단위의 변경이 필요합니다.
- 쿼리 파라미터 버저닝 전략은 패스와 파라미터의 역할을 침범한다고 생각합니다.

커스텀 헤드 전략과 콘텐츠 네고시에이션은 좀 더 RESTful 한 설계가 가능하기에 좋아보였습니다.

하지만 RESTful 함보다는 컨슈머 친화적인 설계를 지향하기에 고려의 대상이 있습니다.

- 컨슈머의 사용이 어렵고, 무엇보다 변경을 인지하는 것이 어렵습니다.
  - (드물지만) 헤더 사용이 제한된 컨슈머가 존재할 수 있습니다.
- 내부용으로 사용된다면 충분히 좋은 선택이라고 생각합니다.

컨슈머의 설정 전략은 컨슈머 친화적이지만 프로바이더에서 고려할 것이 너무 많습니다.

필자는 위의 이유들로 경로 전략을 추천하고, API 사용법을 포함하여 단점을 보완해보았습니다.

- 의미있는 에러 메세지를 구현합니다.
  - Deprecate 된, 또는 예정을 알려줄 수 있습니다.
  - 응답 코드를 활용하는 것도 좋습니다. (407, 408)
  - HATEOAS 를 구현하는 경우 link 를 고려합니다.
- 버저닝은 리소스 단위로 관리합니다.
  - 비록 일부 API 는 브레이킹 체인지가 없다고 하더라도, 컨슈머의 직관적인 인지를 돕습니다.
- 하위 호환성을 고려합니다.
  - 낱개의 필드보다는 네이밍된 객체를 사용합니다.
  - 단순 조회성 API 라면 요건 변경에 따른 필드는 추가하되 기존의 필드도 남겨두는 것을 고려합니다.
    - (비록 response 의 크기는 커지지만) 일부 값의 부재로 생기는 전체 에러를 방지하고, 나머지는 정상적으로 보여줄 수 있습니다.
    - 단 컨슈머가 응답으로 추가적인 연산을 하는 경우는 안됩니다. 오히려 의도하지 않은 문제가 발생하고 추적이 더 어려워집니다.
- 변경이 잦은 리소스는 분리를 고려합니다.
  - 변경이 적은 핵심 리소스와 변경이 많은 유동적인 리소스로 분리합니다. 또는 재설계 합니다.

# 후기

혹자는 원칙과 기술에 입각한 설계와 개발만이 서비스의 수명을 길게 해준다고 말하지만,   
저는 이상적인 설계와 개발은 프로바이더와 컨슈머 모두 충분한 숙련자이고, 충분한 기간이 보장될 때 가능하다고 생각합니다.  
하지만 발전하는 기술 앞에 저는 항상 비숙련자이고, 컨슈머의 숙련도는 예측할 수 없습니다. 우리의 시간은 항상 부족하고, 요건은 변하며 완벽함은 영원히 보증할 수 없습니다.

너무 당연하고 재미없는 이론만 나오는 초반과 다르게 3부 부터는 챕터 마다마다 저자의 내공이 터져나옵니다.  
특히 11 챕터에서는 컨텍스트에 대한 이해를 강조하고, 13 챕터에서는 다각적 관점의 API 리뷰와 소통을 말합니다.  
저는 책의 다른 그 어떤 내용보다 이 두 챕터가 서비스의 수명을 길게 하고 가치가 높은 개발자가 되는 방법이라고 생각합니다.

비지니스는 무엇보다 앞에 있어야하고, 내 실력보다는 친절하고 동료 직원이 일하기 편하게 만드는 개발자가 되고 싶습니다. 

~~근데 그러려면 실력이 좋아야됨.~~
