API Versioning 은 불특정 다수의 컨슈머가 접속하는 OpenAPI 를 지원하기 위한 필수적인 요소 중 하나입니다.  
설령 컨슈머가 한 곳이라고 하더라도 원활한 적용과 장애 시간 최소화를 위해 고려할 수 있습니다. (물론 훌륭한 배포 전략을 준비하면 더 좋습니다.)  
아래는 `일상 속 사물이 알려주는 웹 API 디자인 - 아노드 로렛 저` 를 읽고 해결한 고민과 경험입니다.

```text
브레이킹 체인지: 호환성을 지원하지 않게 되는 변경 (특히 하위 호환성)
컨슈머: API 를 사용하는 클라이언트 (프론트) 
프로바이더: API 를 제공하는 서버 (백엔드)
```

## Versioning 전략

API 를 제공하다보면 브레이킹 체인지를 만나는건 필연적입니다.  
다만 운영 방법에 따라 컨슈머의 인지를 돕고, 프로바이더는 더 적은 변화의 개발을 할 수 있습니다.

| 전략                | v1                                                                                    | v2                                                                                    |
| ------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 경로                | GET /v1/transfers<br>Host: api.bankingcompany.com                                     | GET /v2/transfers<br>Host: api.bankingcompany.com                                     |
| 도메인              | GET /transfers<br>Host: api.bankingcompany.com                                        | GET /transfers<br>Host: apiv2.bankingcompany.com                                      |
| 쿼리 파라미터       | GET /transfers?version=1<br>Host: api.bankingcompany.com                              | GET /transfers?version=2<br>Host: api.bankingcompany.com                              |
| 커스텀 헤드         | GET /transfers<br>Host: api.bankingcompany.com<br>Version: 1                          | GET /transfers<br>Host: api.bankingcompany.com<br>Version: 2                          |
| 콘텐츠 네고시에이션 | GET /transfers<br>Host: api.bankingcompany.com<br>Accept: application/vnd.bank.1+json | GET /transfers<br>Host: api.bankingcompany.com<br>Accept: application/vnd.bank.2+json |
| 컨슈머의 설정       | GET /transfers<br>Host: api.bankingcompany.com<br>Authorization: Bearer 4R57TD78      | GET /transfers<br>Host: api.bankingcompany.com<br>Authorization: Bearer 4R57TD78      |

> 선호하지 않는 버저닝 전략

도메인 전략과 쿼리 파라미터 전략은 가장 선호하지 않는 전략입니다.

1. 도메인 버저닝 전략은 작은 변경에도 도메인이라는 비교적 큰 단위의 변경이 필요합니다.
2. 쿼리 파라미터 버저닝 전략은 패스와 파라미터의 역할을 침범한다고 생각합니다.

커스텀 헤드 전략과 콘텐츠 네고시에이션은 좀 더 RESTful 한 설계가 가능하기에 좋아보였습니다.  
하지만 RESTful 함보다는 컨슈머 친화적인 설계를 지향하기에 선택하지 않았습니다.

1. 컨슈머의 사용이 어렵고, 무엇보다 변경을 인지하는 것이 어렵습니다.
   - (드물지만) 헤더 사용이 제한된 컨슈머가 존재할 수 있습니다.
2. 내부용으로 사용된다면 충분히 좋은 선택이라고 생각합니다.

컨슈머의 설정 전략은 컨슈머 친화적이지만 프로바이더에서 고려할 것이 너무 많습니다.

> 경로 버저닝 전략

필자는 경로 전략을 추천합니다.  
그리고 API 사용에 대한 철학을 포함하여 단점을 보완합니다.

1. 의미있는 에러 메세지를 구현합니다.
   - Deprecate 된, 또는 예정을 알려줄 수 있습니다.
   - 응답 코드를 활용하는 것도 좋습니다. (407, 408)
   - HATEOAS 를 구현하는 경우 link 를 고려합니다.
2. 버저닝은 리소스 단위로 관리합니다.
   - 비록 일부 API 는 브레이킹 체인지가 없다고 하더라도, 컨슈머의 직관적인 인지를 돕습니다.
3. 하위 호환성을 고려합니다.
4. 낱개의 필드보다는 네이밍된 객체를 사용합니다.
   - null 인 객체/필드는 내려보내지 않음으로서 컨슈머가 옵셔널 처리를 할 수 있도록 유도합니다.
5. 단순 조회성 API 라면 요건 변경에 따른 필드는 추가하되 기존의 필드도 남겨두는 것을 고려합니다.
   - (비록 response 의 크기는 커지지만) 일부 값의 부재로 생기는 전체 에러를 방지하고, 나머지는 정상적으로 보여줄 수 있습니다.
   - 단 컨슈머가 응답으로 추가적인 연산을 하는 경우는 안됩니다. 오히려 의도하지 않은 문제가 발생하고 추적이 더 어려워집니다.
6. 변경이 잦은 리소스는 분리를 고려합니다.
   - 변경이 적은 핵심 리소스와 변경이 많은 유동적인 리소스로 분리합니다. 또는 재설계 합니다.
7. 컨슈머에게 친절한 API 를 만듭니다.
   - 컨슈머가 넣어야하는 param 에 디폴트 값을 넣어줍니다.
   - 하위 리소스가 유일할 경우 id 를 생략합니다.
     - ex) 영화에는 별점이 1개만 존재합니다.
       - Good - PUT /movie/{movieId}/rating
       - Bad - PUT /movie/{movieId}/rating/{ratingId}

## 후기

혹자는 원칙과 기술에 입각한 설계와 개발만이 서비스의 수명을 길게 해준다고 말합니다. 하지만 저는 이상적인 설계와 개발은 프로바이더와 컨슈머 모두 충분한 숙련자이고, 충분한 기간이 보장될 때 가능하다고 생각합니다.  
발전하는 기술 앞에 저는 항상 비숙련자이고, 컨슈머의 숙련도는 예측할 수 없습니다. 우리의 시간은 항상 부족하고, 요건은 변하며 완벽함은 영원히 보증할 수 없기 때문입니다.

너무 당연하고 재미없는 이론만 나오는 초반과 다르게 3부부터는 챕터마다 저자의 내공이 터져나옵니다.  
특히 컨텍스트의 이해를 강조하는 11 챕터와 다각적 관점의 API 리뷰와 소통을 말하는 13 챕터가 제일 공감되었습니다.  
다른 그 어떤 기술적인 내용보다 이 두 챕터가 서비스의 수명을 길게 하고 가치 높은 개발자가 되는 길이라고 생각합니다.

시작은 버저닝으로 했는데 결론은 친절한 API 를 만들자가 되었네요.

~~근데 그러려면 실력이 좋아야됨.~~
